# Архитектурный план: Приложение для мониторинга ставок финансирования Bybit

## 1. Обзор

Этот документ описывает архитектуру Flutter-приложения для отслеживания ставок финансирования (funding rates) для perpetual-контрактов на бирже Bybit.

## 2. Структура проекта

Предлагается следующая структура директорий для организации кода:

```
lib/
|
├── main.dart                 # Точка входа в приложение
|
├── app/
│   ├── core/
│   │   ├── config/           # Конфигурация приложения (темы, константы)
│   │   ├── di/               # Настройка Dependency Injection
│   │   ├── network/          # Сетевые утилиты, интерсепторы
│   │   └── use_cases/        # Абстракции для бизнес-логики
│   │
│   ├── data/
│   │   ├── datasources/
│   │   │   └── bybit_api/
│   │   │       ├── bybit_api_client.dart # Клиент для Bybit API
│   │   │       └── models/               # Модели данных API (DTO)
│   │   │
│   │   ├── repositories/
│   │   │   └── funding_rate_repository_impl.dart # Реализация репозитория
│   │   │
│   │   └── local/            # Локальное хранилище (кэш, настройки)
│   │       └── ...
│   │
│   ├── domain/
│   │   ├── entities/         # Бизнес-сущности (чистые модели)
│   │   └── repositories/
│   │       └── funding_rate_repository.dart # Абстрактный репозиторий
│   │
│   └── presentation/
│       ├── features/
│       │   ├── instrument_list/ # Фича: список инструментов
│       │   │   ├── widgets/
│       │   │   ├── cubit/ | bloc/
│       │   │   └── instrument_list_screen.dart
│       │   │
│       │   └── instrument_details/ # Фича: детали инструмента и график
│       │       ├── widgets/
│       │       ├── cubit/ | bloc/
│       │       └── instrument_details_screen.dart
│       │
│       └── common_widgets/     # Общие виджеты UI
|
└── generated/                # Сгенерированные файлы (локализация, моки)
```

## 3. Слои приложения

Архитектура будет основана на принципах чистой архитектуры (Clean Architecture), разделяя приложение на три основных слоя:

*   **Presentation Layer (Слой представления):**
    *   Отвечает за отображение UI и обработку пользовательского ввода.
    *   Содержит виджеты Flutter, экраны и компоненты управления состоянием (State Management), такие как BLoC или Cubit.
    *   Не содержит бизнес-логики. Запрашивает данные у Domain Layer через use cases.

*   **Domain Layer (Доменный слой):**
    *   Содержит основную бизнес-логику приложения.
    *   Включает в себя бизнес-сущности (entities), юзкейсы (use cases) и абстрактные репозитории.
    *   Этот слой не зависит от других слоев. Он определяет, *что* приложение делает, но не *как*.

*   **Data Layer (Слой данных):**
    *   Отвечает за получение данных из различных источников (API, база данных, кэш).
    *   Содержит реализации репозиториев, определенных в Domain Layer.
    *   Включает в себя клиенты для работы с API, модели данных (DTO - Data Transfer Objects) и код для работы с локальным хранилищем.

## 4. Необходимые зависимости и пакеты

Для реализации функционала потребуются следующие пакеты из [pub.dev](https://pub.dev/):

*   **Управление состоянием:**
    *   `flutter_bloc` / `bloc`: для реализации паттерна BLoC (Business Logic Component) для управления состоянием экранов.
*   **DI (Dependency Injection):**
    *   `get_it`: для внедрения зависимостей и обеспечения слабой связности компонентов.
    *   `injectable`: для кодогенерации и упрощения настройки `get_it`.
*   **Работа с сетью:**
    *   `dio`: мощный HTTP-клиент для выполнения запросов к Bybit API. Поддерживает интерсепторы, обработку ошибок.
    *   `retrofit` (опционально): для генерации REST-клиента на основе аннотаций, что упрощает код API-слоя.
*   **Построение графиков:**
    *   `fl_chart`: гибкая библиотека для создания красивых и интерактивных графиков.
*   **Локальное хранилище и безопасность:**
    *   `shared_preferences`: для хранения простых настроек (например, выбранная тема, интервал автообновления).
    *   `flutter_secure_storage`: для безопасного хранения API-ключей пользователя.
    *   `hive` или `drift` (ранее `moor`): для кэширования данных, чтобы уменьшить количество запросов к API и обеспечить оффлайн-доступ к ранее загруженным данным.
*   **Утилиты:**
    *   `equatable`: для упрощения сравнения объектов.
    *   `intl`: для форматирования дат и чисел.

## 5. Диаграмма потока данных

```mermaid
graph TD
    subgraph Presentation Layer
        UI[Виджеты Flutter] -- User Action --> SM[State Management <br> BLoC/Cubit]
        SM -- Calls Use Case --> UC[Use Case]
        SM -- Updates State --> UI
    end

    subgraph Domain Layer
        UC -- Accesses Repository --> Repo[Абстрактный репозиторий]
        Entity[Бизнес-сущность]
    end

    subgraph Data Layer
        RepoImpl[Реализация репозитория] -- Implements --> Repo
        RepoImpl -- Gets Data --> API[Bybit API Client <br> (Dio)]
        RepoImpl -- Gets/Saves Data --> Cache[Локальное хранилище <br> (Hive/Drift)]
    end

    API -- HTTP Request --> Bybit[Bybit API]
    Bybit -- HTTP Response --> API

    UC --> Entity
    Repo -- Returns --> Entity
```

## 6. Хранение данных

*   **Кэширование:** Данные, полученные от API (список инструментов, история ставок), следует кэшировать локально. Это позволит:
    *   Ускорить повторную загрузку данных.
    *   Отображать данные при отсутствии интернет-соединения.
    *   Снизить нагрузку на API Bybit.
    *   Рекомендуется использовать `Hive` или `Drift` для этой цели. Кэш должен иметь время жизни (TTL), чтобы данные периодически обновлялись.

*   **Настройки пользователя:** Простые настройки, такие как выбранная тема или фильтры по умолчанию, можно хранить с помощью `shared_preferences`.

## 7. Обработка состояний и ошибок

*   **Состояния UI:** Каждый экран или компонент, работающий с асинхронными данными, должен обрабатывать следующие состояния:
    *   `Loading`: идет загрузка данных (отображается индикатор прогресса).
    *   `Success`: данные успешно загружены (отображается контент).
    *   `Error`: произошла ошибка (отображается сообщение об ошибке и, возможно, кнопка "Повторить").
    *   `Empty`: данные загружены, но список пуст.

    Эти состояния удобно моделировать с помощью `sealed classes` в Dart и управлять ими через BLoC/Cubit.

*   **Ошибки API:**
    *   Необходимо обрабатывать различные типы ошибок: отсутствие интернет-соединения, ошибки сервера (5xx), ошибки клиента (4xx), тайм-ауты.
    *   Использование `dio` с интерсепторами позволит централизованно обрабатывать ошибки, логировать их и преобразовывать в понятные для пользователя сообщения.

## 8. Обновление данных

*   **Ручное обновление:** В пользовательском интерфейсе должна быть кнопка "Обновить", которая инициирует немедленный запрос свежих данных с API.
*   **Автоматическое обновление:**
    *   В настройках приложения пользователь может включить опцию автообновления.
    *   Пользователь также должен иметь возможность задать интервал обновления в секундах.
    *   Для реализации этой функциональности можно использовать `Timer.periodic` или поток (`Stream`), который будет инициировать запрос данных через заданный промежуток времени.
    *   Важно предусмотреть механизм отмены таймера при закрытии экрана или выключении функции, чтобы избежать утечек памяти.

## 9. Аутентификация и безопасность

*   **Пользовательские API-ключи:** Приложение должно предоставлять пользователю возможность добавить свой собственный API-ключ и секрет от биржи Bybit.
*   **Безопасное хранение:** API-ключи и секреты являются конфиденциальной информацией. Их следует хранить в безопасном хранилище, а не в `shared_preferences`. Для этой цели рекомендуется использовать пакет `flutter_secure_storage`.
*   **Использование ключей:** При выполнении запросов к API, требующих аутентификации, `Dio` интерсептор должен будет считывать сохраненные ключи и добавлять необходимые заголовки к запросу в соответствии с документацией Bybit API.
*   **UI для управления ключами:** Необходимо создать отдельный экран в настройках, где пользователь сможет добавлять, просматривать (частично скрыв ключ), обновлять и удалять свои API-ключи.